## 题目21 — 调整数组使得奇数位于偶数之前

输入一个整数数组，实现一个函数来调整该数组中数字的顺序。

使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。

**示例:** 

> 输入：`[1,2,3,4,5]`
>
> 输出： `[1,3,5,2,4]`

### 答案

#### 方法一: 使用额外空间

如果可以使用额外的空间。O(n)的空间和O(n)的时间复杂度。思路很简单：

- 第一次遍历，将奇数存入辅助数组中；
- 第二次遍历，将偶数存入数组中；
- 辅助数组的元素覆盖原数组。

###### 代码

```java
public static void reOrderArray1(int[] array) {
    // 分别存放奇数和偶数
    ArrayList<Integer> odd = new ArrayList<Integer>();
    ArrayList<Integer> even = new ArrayList<Integer>();

    for (int i = 0; i < array.length; i++) {
        // 如果是奇数
        if (array[i] % 2 != 0) {
            odd.add(array[i]);
        } else {
            even.add(array[i]);
        }
    }
    // 将偶数放到奇数末尾
    odd.addAll(even);

    for (int i = 0; i < array.length; i++) {
        array[i] = odd.get(i);
    }
}
```

#### 方法二: 类冒泡排序

###### 代码

```java
// 冒泡排序
public static void reOrderArray2(int[] array) {
    for (int i = 0; i < array.length; i++) {
        // 内层循环, 相对位置进行交换, 每轮循环下来, 最后一个位置上面的数字是正确的
        for (int j = 0; j < array.length - i - 1; j++) {
            // 如果当前的值为偶数，后一个值为奇数，则两个数对换位置
            if (array[j] % 2 == 0 && array[j + 1] % 2 == 1) {
                int temp = array[j + 1];
                array[j + 1] = array[j];
                array[j] = temp;
            }
        }
    }
}
```

#### 扩展

如果没有要求相对顺序, 所有奇数在偶数之前就可以了，不要求保持原来的相对位置。则本题可以用一次遍历完成。

思路如下(类似快速排序, 快速排序本身就是不稳定的)：

- 设置两个指针，一个指针pBegin指向数组第一个元素，一个指针pEnd指向数组的最后一个元素；
- 当pBegin < pEnd时：pBegin指针不断右移，直到遇到某个偶数为止；同样的，pEnd不断左移，直到遇到某个奇数为止。
- 若此时pBegin < pEnd：交换两个元素，因此排在前面的奇数被交换到了后面。

###### 代码

```java
public static void reOrderArray3(int[] array) {
    if (array == null || array.length == 0)
        return;

    int pBegin = 0;
    int pEnd = array.length - 1;
    while (pBegin < pEnd) {
        // 左到右找出第一个偶数
        while (pBegin < pEnd && array[pBegin] % 2 != 0)
            pBegin++;

        // 右到左找出第一个奇数
        while (pBegin < pEnd && array[pEnd] % 2 == 0)
            pEnd--;

        // 交换两个奇数和偶数，奇数被换到了前面，偶数换到了后面
        if (pBegin < pEnd) {
            int temp = array[pBegin];
            array[pBegin] = array[pEnd];
            array[pEnd] = temp;
        }
    }
}
```



## 题目22 — 链表中倒数第 k个节点

输入一个链表，输出该链表中倒数第 k 个结点。

**注意：**

- `k >= 0`;
- 如果 k 大于链表长度，则返回 NULL;

**示例:** 

> 输入：链表：`1->2->3->4->5`，`k=2`
>
> 输出：4

### 答案

#### 思路

使用快慢指针

1. 定义两个指针，第一个指针从链表的头指针开始遍历向前走`k-1`步，第二个指针保持不动，
2. 从第`k`步开始，第二个指针也开始从链表的头指针开始遍历
3. 由于两个指针的距离保持在`k-1`，当第一个指针到达链表的尾节点时，第二个指针刚好指向倒数第`k`个节点。

###### 代码

```java
public ListNode FindKthToTail(ListNode head, int k) {

    if (k <= 0 || head == null)
        return null;

    // 初始化快慢指针
    ListNode quickPtr = head;
    ListNode slowPtr = head;

    for (int i = 0; i < k - 1; i++) {
        // 如果 k的值比链表结点数还大
        if (quickPtr.next == null) {
            return null;
        }
        quickPtr = quickPtr.next;
    }
    // 最后 quickPtr指向尾节点
    while (quickPtr.next != null) {
        quickPtr = quickPtr.next;
        slowPtr = slowPtr.next;
    }
    return slowPtr;
}
```



## 题目23 — 链表中环的入口结点

给定一个链表，若其中包含环，则输出环的入口节点。

若其中不包含环，则输出`null`。

**示例:**

![pro23](E:\Git\data-structure-and-algorithm\剑指offer(Java)\图片\问题\pro23.png)

给定如上所示的链表：`[1, 2, 3, 4, 5, 6]`，编号：2。
注意，这里的 2 表示编号是 2 的节点，节点编号从 0 开始。所以编号是 2 的节点就是 val 等于 3 的节点。

则输出环的入口节点 3 。

### 答案

#### 方法一: 双指针法

##### 理解

如下图，Y是环的入口结点，X是链表头结点。X、Y之间的步数为a。假设按照a -> b -> c ->b -> c...的顺序走。pFast走两步的同时pSlow走一步，最后他们一定会相遇。

> **为什么一定会相遇？**
>
> 试想操场跑步，你跑得快就能超出跑得慢的同学好多圈；同样地如果链表有环，pFast一定会和pSlow的距离逐渐缩小，直到相遇。（最好画画图加深理解）

##### 思路

1. 假设pFast和pSlow在**Z处相遇**。他们相遇时，pFast走过的步数一定是pSlow的两倍，即有**$$S_{fast} = 2S_{slow}$$**

2. 假设相遇时pFast在环内转了k圈，则(因为速度是2倍的关系, 所以 pSlow在跑完一圈内一定和 pFast相遇过) **$$a + k(b+c) + b = 2(a + b), k \ge 1$$**

   移项得：**$$a = (k-1)(b+c) + c, k \ge 1$$**

**上面的等式说明：**X到 Y的步数 a等于从 Z处开始在环内转 k-1圈后，再从 Z到 Y的步数是一样的。**(距离相等)**

##### 解题

现在将 pFast移动到 X，pSlow保持在Z处(距离 Y还有 c的距离)，两者同时每次走一步(抛掉2倍的关系)，pFast走 a步，pSlow走 (k-1)(b+c) + c步，它们刚好会在Y处相遇，由此找到了这个入口结点

![ans_23](E:\Git\data-structure-and-algorithm\剑指offer(Java)\图片\答案\ans_23.png)

###### 代码

```java
public ListNode entryNodeOfLoop(ListNode pHead) {
    // 两个指针, 快慢指针
    ListNode pFast = pHead;
    ListNode pSlow = pHead;

    // 跳出循环说明没有环
    while (pFast != null && pFast.next != null) {
        // 快指针走两步, 慢指针走一步
        pFast = pFast.next.next;
        pSlow = pSlow.next;
        // 相等时说明有环, 在 Z点相遇
        if (pFast == pSlow) {
            pFast = pHead;
            while (pFast != pSlow) {
                pFast = pFast.next;
                pSlow = pSlow.next;
            }
            // 在入口节点处相遇
            return pSlow;
        }
    }
    return null;
}
```

#### 方法二: 使用 Set

Set中不能存放相同的元素。当在遍历链表的过程中，不断将当前结点放入Set中，当**第一次add失败**时，说明这个结点之前已经访问过了，这个结点刚好就是环的入口结点。

###### 代码

```java
public ListNode entryNodeOfLoop_set(ListNode pHead) {
    if (pHead == null) return null;

    Set<ListNode> set = new HashSet<>();
    ListNode cur = pHead;
    while (cur != null) {
        if (!set.add(cur)) {
            return cur;
        }
        cur = cur.next;
    }
    return null;
}
```



