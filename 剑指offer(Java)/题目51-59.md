## 第 59 题：滑动窗口的最大值

给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。

**注意：**数据保证 k大于 0 ，且 k小于等于数组长度。

**样例：**

```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

### 答案

#### 思路

只将有可能成为滑动窗口中的最大值的元素入列

使用双端队列，**队列头永远存放当前滑动窗口的最大值，而队列尾存放候选最大值，即当队列头的最大值弹出后成为新的最大值的那些元素**。

#### 实例描述

1. 一开始2进入队列，然后3进入队列，因为3比2大，所以2不可能是滑动窗口的最大值。因此先将2从队列中弹出，然后3入列；接下来4入列也类似：将3弹出，4入列，目前队列中只有一个元素，且滑动窗口中已经有三个数字了，所以此时窗口中的最大值是位于队列头的4。
2. 接下来2入列，虽然比4小，但是不知道什么时候4将会位于滑动窗口之外，所以这个2还是有一定可能成为窗口中的最大值的，应该将其入列，注意应该排在队列的尾部，因为队列头始终是当前窗口的最大值。由于队列头还是4，所以此时窗口中的最大值还是4。
3. 然后6入列，队列中的4和2都不可能成为窗口中的最大值了，因此应该先从队列中弹出4和2然后再将6入列....后面的分析也大同小异。
4. ......
5. 再看最后一个元素1，它入列前，队列中有6和5，且6位于队列头是窗口中的最大值，按照之前的做法，应该将1入列，但是窗口的大小为3，此时队列头的6已经在窗口之外了，所以要讲6从队列中弹出，那么此时队列中还剩下5和1且5位于队列头，所以最后一个窗口中的最大值是5。

**那么如何判断某个元素还在不在窗口内呢？我们应该在往队列中存元素的下标而不是元素本身。**若当前正访问的元素的下标与窗口最大值的下标（即队列头元素的下标）超过了窗口的宽度，就应该从队列头删除这个在滑动窗口之外的最大值。

#### 视频解析

[参考 leetcode题解视频解析](https://leetcode-cn.com/problems/sliding-window-maximum/solution/shi-pin-jie-xi-shuang-duan-dui-lie-hua-dong-chuang/)

#### 总结

- 即将要入列的的元素比队列中哪些元素大或者相等，就将那些元素先从队列中删除，然后再入列新元素；
- 队列头的最大值如果位于滑动窗口之外，则需要将队列头的最大值从队列中删除；
- 当前下标加上1（因为下标从0开始计）等于窗口宽度的时候就可以开始统计滑动窗口的最大值了

###### 代码

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    int len = nums.length;
    if (len == 0) return new int[]{};

    List<Integer> res = new ArrayList<>();
    // 滑动窗口(双端队列)，注意：保存的是索引值
    ArrayDeque<Integer> deque = new ArrayDeque<>(k);

    for (int i = 0; i < len; i++) {

        // 添加下标 i后, 队列中的数目 > 窗口宽度, 将队首元素弹出
        if (i >= k && i - deque.getFirst() == k)
            deque.pollFirst();

        // 如果滑动窗口非空，新进来的数比队列里已经存在的数还要大, 则说明已经存在数一定不会是滑动窗口的最大值, 将它们弹出
        // 例子: 滑动窗口为[5, 3, 2], 添加元素为 4, 循环完后变成 [5, 4]
        while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()])
            deque.pollLast();

        // 将元素添加到队列中, 注意是添加下标
        deque.add(i);
        // 保证队列中的元素值 >= 窗口宽度, 队首一定是滑动窗口的最大值的索引
        if (i + 1 >= k)
            res.add(nums[deque.peekFirst()]);

    }

    // 赋值操作
    int size = res.size();
    int[] result = new int[size];

    for (int i = 0; i < size; i++)
        result[i] = res.get(i);

    return result;
}
```

