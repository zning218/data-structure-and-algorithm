## 题目 33

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。

如果是则返回 true，否则返回 false。

假设输入的数组的任意两个数字都互不相同。

**样例：**

> 输入：`[4, 8, 6, 12, 16, 14, 10]`
>
> 输出：`true`

### 答案

#### 思路

对于一个序列 S，最后一个元素是该树的跟节点, 设为 x

如果是后序遍历, 则应该满足: T可以分成两段, 如果满足

1. 前一段(左子树)小于 x，
2. 并且后一段(右子树)大于 x，
3. 则这两段（子树）都是合法的后序序列

完美的递归定义   : ) 

###### 代码

```java
public class Pro33 {

    // 程序入口
    public boolean VerifySquenceOfBST(int[] sequence) {
        if (sequence == null || sequence.length == 0) {
            return false;
        }
        return isBST(sequence, 0, sequence.length - 1);
    }

    // 在 l-r范围内, 是否满足后序遍历的条件
    private boolean isBST(int[] seq, int l, int r) {
        // 递归结束条件, 只剩下一个节点
        if (l >= r) {
            return true;
        }

        int val = seq[r];   // 获取根节点的值
        int split = l;      // 左右子树的数值分割位置
        // 找到分割位置, 右子树的第一个值
        for (; split < r && seq[split] < val; split++) ;

        // 右子树中的所有数值 > 根节点的值
        for (int i = split; i < r; i++) {
            if (seq[i] < val) {
                return false;
            }
        }
        // 再对左右子树一次进行判断
        return isBST(seq, l, split - 1) && isBST(seq, split, r - 1);
    }
}
```



## 题目34 — 二叉树中和为某一值的路径

输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。

从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

**样例: **

```
给出二叉树如下所示，并给出num=22。
		  5
         / \
        4   6
       /   / \
     12  13  6
    /  \    / \
   9    1  5   1
1234567
输出：[[5,4,12,1],[5,6,6,5]]
```

### 答案

回溯 + 递归, 具体解见代码

###### 代码

```java
public class Pro34 {

    private ArrayList<ArrayList<Integer>> res;  // 存储结果
    private int target;     // 目标值

    // 程序入口
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root, int target) {
        // 进行初始化工作
        this.res = new ArrayList<>();
        this.target = target;

        findPath(root, 0, new ArrayList<>());
        return res;
    }

    // 进行递归
    private void findPath(TreeNode node, int curSum, ArrayList<Integer> pre) {
        // 递归结束条件
        if (node == null) return;

        // 下面均是逻辑部分
        pre.add(node.val);
        curSum += node.val;
        // 该结点为叶子结点, 并且该路径的值与剩余值相等
        // 已经是叶子结点了， 不必再继续向下遍历
        if (node.left == null && node.right == null && curSum == target) {
            res.add(new ArrayList<>(pre));
        } else {
            findPath(node.left, curSum, pre);
            findPath(node.right, curSum, pre);
        }
        // 回溯， 状态清除， 移除最后一个元素
        pre.remove(pre.size() - 1);
    }
}
```



## 题目36 — 二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。

要求不能创建任何新的结点，只能调整树中结点指针的指向。

**注意: **需要返回双向链表最左侧的节点。

**示例:** 输入下图中左边的二叉搜索树，则输出右边的排序双向链表

![题目36](.\图片\问题\题目36.jpg)

### 答案

#### 思路

搜索二叉树，按序输出，一定是递归操作，而且是中序遍历的形式做操作

关键是将之前的中序遍历的输出这个操作调整为编程双项链表

设置两个指针，分别指向双向链表的最左、最优结点

关键操作：

本次遍历到的结点即为操作的结点，目的是将它放到双向链表的最后面（因为是中序遍历）

![二叉搜索树](.\图片\答案\二叉搜索树.png)

###### 代码

```java
public class Pro36 {

    // 双向链表的左边头结点和右边头节点
    TreeNode leftHead = null;
    TreeNode rightHead = null;

    // 程序入口, 递归中序遍历, 左, 根, 右
    public TreeNode Convert(TreeNode pRootOfTree) {
        // 空树时递归结束
        if (pRootOfTree == null) return null;

        // 第一次运行时，它会使最左边叶子节点为链表第一个节点
        Convert(pRootOfTree.left);

        // 初始化第一个节点
        if (rightHead == null) {
            leftHead = rightHead = pRootOfTree;
        } else {
            // 把根节点插入到双向链表右边，rightHead向后移动

            rightHead.right = pRootOfTree;
            pRootOfTree.left = rightHead;
            rightHead = pRootOfTree;
        }

        // 把右叶子节点也插入到双向链表（rightHead已确定，直接插入）
        Convert(pRootOfTree.right);
        // 返回左边头结点
        return leftHead;
    }
}
```



## 题目37 — 序列化二叉树

请实现两个函数，分别用来序列化和反序列化二叉树。

您需要确保二叉树可以序列化为字符串，并且可以将此字符串反序列化为原始树结构。

**示例：**

```
二叉树
    8
   / \
  12  2
     / \
    6   4
序列化为： [8, 12, 2, null, null, 6, 4, null, null, null, null]

注意:以上的格式是 AcWing 序列化二叉树的方式，你不必一定按照此格式，所以可以设计出一些新的构造方式。
```

### 答案

使用先序遍历, 具体看代码

回头实现非递归版

#### 递归版

###### 代码

```java
public class Pro37 {

    // 序列化
    String Serialize(TreeNode root) {
        // 结束条件
        if (root == null) return "$,";

        StringBuilder sb = new StringBuilder(root.val + ",");
        // 遍历左子树
        sb.append(Serialize(root.left));
        // 遍历右子树
        sb.append(Serialize(root.right));
        return sb.toString();
    }

    // 反序列化
    TreeNode Deserialize(String str) {

        // 将字符串中的数字构建成队列中的元素
        String[] strArr = str.split(",");
        LinkedList<String> queue = new LinkedList<>();
        for (String s : strArr)
            queue.addLast(s);

        return preOrder(queue);
    }

    // 使用队列进行还原
    private TreeNode preOrder(LinkedList<String> queue) {

        String s = queue.removeFirst();
        // 只要不是 $
        if (!"$".equals(s)) {
            TreeNode newNode = new TreeNode(Integer.parseInt(s));

            newNode.left = preOrder(queue);
            newNode.right = preOrder(queue);

            return newNode;
        }
        // 是 "$" 就返回空指针，注意这里的递归方法，会把空指针接在原来的树节点上
        return null;
    }
}
```



## 题目38

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

**输入描述:** 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。

### 答案

同 leetcode47, 不同的是没有办法排序, 所以使用 ArrayList去重

###### 代码

```java
public class Pro38 {

    private String str;     // 给定字符串
    private int length;     // 字符串长度，也就是递归次数
    private ArrayList<String> res;
    private boolean[] visited;

    public ArrayList<String> Permutation(String str) {
        this.res = new ArrayList<>();
        this.str = str;
        this.length = str.length();
        this.visited = new boolean[str.length()];

        // 特殊情况
        if (str == null || str == "") return res;
        find(0, "");
        return res;
    }

    private void find(int index, String pre) {
        if (index == length) {
            // 这样去重, 做个小弊
            if (!res.contains(pre)) {
                res.add(pre);
            }
            return;
        }

        for (int i = 0; i < length; i++) {
            if (!visited[i]) {
                visited[i] = true;
                pre = pre + str.charAt(i);
                find(index + 1, pre);
                pre = pre.substring(0, pre.length() - 1);
                visited[i] = false;
            }
        }
    }  
}
```