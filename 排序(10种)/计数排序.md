# 计数排序（Counting Sort）

是非比较排序, 适用于特定的问题

计数排序只适用于正整数并且取值范围相差不大的数组排序使用，它的排序的速度是非常可观的

## 1. 算法思想

​	计数排序不是基于比较的排序算法，其核心在于**将输入的数据值转化为键存储在额外开辟的数组空间中**。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

​	计数排序使用一个**额外的数组C**，**其中第 i 个元素是待排序数组A中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置**。它只能对整数进行排序。

### 2) 算法描述

1. 找出待排序的数组中最大和最小的元素；
2. 统计数组中每个值为 i 的元素出现的次数，存入数组C的第 i 项；
3. 对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；
4. 反向填充目标数组：将每个元素 i 放在新数组的第C(i)项，每放一个元素就将C(i)减去1。

#### 动态演示

![计数排序](.\图片\计数排序.gif)

### 3) 算法实现

```c
public int[] countSort(int[] arr) {

    // 计算计数数组的长度
    int min = Integer.MAX_VALUE;    // 数组中的最小数
    int max = Integer.MIN_VALUE;    // 数组中的最大数
    for (int i = 0; i < arr.length; i++) {
        min = arr[i] < min ? arr[i] : min;
        max = arr[i] > max ? arr[i] : max;
    }
    int countNum = max - min + 1;

    // 计数数组
    int[] countArr = new int[countNum];

    // 将数组中的每个元素依次放入到计数数组中相应位置中
    for (int i = 0; i < arr.length; i++) {
        // 数组中元素应当放入的位置
        int index = arr[i] - min;
        countArr[index]++;
    }

    // 累加数组,存入的值是每个元素对应的下标的最大值 +1 (有很多个重复元素)
    for (int i = 1; i < countArr.length; i++)
        countArr[i] = countArr[i] + countArr[i - 1];

    // 排序后的数组
    int[] res = new int[arr.length];

    // 反向填充目标数组, 保证排序稳定
    for (int i = arr.length - 1; i >= 0; i--) {
        // 找出此时 arr[i]应该放入桶中的位置
        int pos = arr[i] - min;
        // 根据位置找出累加数组中的对应的数, 也就是这个数的最大索引值, 并且赋完值后最大索引值 -1
        int index = --countArr[pos];
        // 逆向填充数组
        res[index] = arr[i];
    }
    return res;
}
```

### 4) 算法分析

| 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 排序方式 | 稳定性 |
| :------------: | :------: | :------: | :--------: | :------: | :----: |
|     O(n+k)​     |  O(n+k)  |  O(n+k)  |   O(n+k)   | 内部排序 |  稳定  |

#### 时间复杂度

 计数排序平均时间复杂度为O(n + k)，最好时间复杂度为O(n + k)，最坏时间复杂度为O(n + k)。n 为遍历一趟数组计数过程的复杂度，k 为遍历一趟桶取出元素过程的复杂度。

#### 空间复杂度

#### n是复制的数组, k 是桶的个数

 计数排序是稳定的。

