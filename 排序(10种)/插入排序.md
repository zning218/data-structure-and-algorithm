#  插入排序（Insertion Sort）

#### 特点

虽然时间复杂度都是O(n^2^) , 但是插入排序比冒泡排序快一倍, 冒泡排序又两两比较, 有两两交换, 次数比较多, 比选择排序也快一点

对于近乎有序的数组, 插入排序的性能要远远快于选择排序

#### 理解

想象调整扑克牌的位置.

![插入排序举例](./图片/插入排序举例.png)



## 1. 算法思想

1. 把数组 R[n] 待排序的 n 个元素看成为**一个有序表和一个无序表**
2. 开始时有序表只有一个元素 R1 , 而无序表包含有 n-1 个元素 R[2]-R[n] . 
3. 排序过程中，每次**取出无序表中的一个元素，将它插入到有序表的适当位置，使之成为新的有序表**
4. 这样经过 n-1 次插入后,无序表变为空表而**有序表包含n个元素**，排序完毕

> 将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过

## 2. 算法描述

1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5. 将新元素插入到该位置后；
6. 重复步骤2~5

#### 动态演示

![直接插入排序](./图片/直接插入排序.gif)

## 3. 算法实现

###### 代码一

**实现难点:** 

1. 想象玩牌是的插入, 找到算法思路

2. 弄清楚 `i` 下标的含义, 注意临界值

3. 弄清楚是如何进行找到合适位置的

```java
public static void insertionSort(int[] arr) {
	// i代表待插入元素, 第一个默认有序
    for (int i = 1; i < arr.length; i++) {
        // 每次和下标为 j的前一个元素进行比较
        for (int j = i; j > 0; j--) {
            if (arr[j] < arr[j - 1]) {
                int temp = arr[j];
                arr[j] = arr[j - 1];
                arr[j - 1] = temp;
            } else  // 如果不进行交换, 说明找到合适位置, 进跳出循环
                break;
        }
    }
}
```

找到合适的位置后, 会提前结束比较, 按理来说比选择排序要快, 但是因为有大量的交换操作, 所以会使时间变慢, 比选择排序要慢

###### 代码二

优化后没有大量的交换(动态图中演示的)

**实现难点:** 

1. 想清楚如何实现代码
2. 明确 i, j的含义

代码

```java
public static void insertionSort2(int[] arr) {
    // i代表待插入的元素
    for (int i = 1; i < arr.length; i++) {
        int j = i;	// j代表要插入位置的下标
        int val = arr[i];
        // 保证下标不越界并且找到属于自己的位置, 注意条件顺序不能颠倒
        while (j - 1 >= 0 && arr[j - 1] > val) {
            arr[j] = arr[j - 1];
            j--;
        }
        // 插入属于他的位置
        arr[j] = val;
    }
}
```

这样就比选择排序要快

## 4. 算法分析

| 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 排序方式 | 稳定性 |
| :------------: | :------: | :------: | :--------: | :------: | :----: |
|    O(n^2^)​     |   O(n)   | O(n^2^)  |    O(1)    | 内部排序 | 不稳定 |

#### 解析

- **最好情况：**如果待排序元素本来是正序的，每个元素比较和移动元素的次数分别是 1 和 0，因此最好情况的时间复杂度为O(n)。所以对于近乎有序的数组, 他的速度可能会比O(nlogn)快
- **最坏情况：**如果待排序元素本来是逆序的，需要进行 (n - 1) 趟排序，所需比较和移动次数分别为 n * (n - 1) / 2和 n * (n - 1) / 2。因此最坏情况下的时间复杂度为O(n^2^)

* **空间复杂度: ** 直接插入排序使用了常数空间，空间复杂度为O(1)

* **稳定性: ** 直接插入排序是稳定的

## 5. 算法拓展(还没有看)

 在直接插入排序中，待插入的元素总是在有序区线性查找合适的插入位置，没有利用有序的优势，考虑使用二分查找搜索插入位置进行优化，即**二分插入排序**。