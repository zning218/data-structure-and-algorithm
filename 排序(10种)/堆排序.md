# 堆排序（Heap Sort）

时间上不如归并排序和快速排序, 在系统级别排序很少有使用堆排序的, 堆更多的使用在数据的动态维护. 

## 1. 算法思想

堆排序是一种树形选择排序方法，它利用了**堆**这种数据结构。在排序的过程中，将array[0，...，n-1]看成是一颗**完全二叉树**的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的关系，在当前无序区中选择关键字最大（最小）的元素。

## 2. 概念

#### **堆：**

​	堆是一种**完全二叉树**，且满足所有父节点的值均大于等于（或小于等于）其子节点的值。

#### **大根堆（最大堆）：**

​	满足所有父节点的值均大于等于其子节点的值的堆称为大根堆，堆顶元素是堆中元素的最大值。

#### **小根堆（最小堆）：**

​	满足所有父节点的值均小于等于其子节点的值的堆称为小根堆，堆顶元素是堆中元素的最小值。

#### **堆的顺序存储结构** : 

​	使用顺序数据结构（数组）存储堆，表示方法为：

1. 数组按层序遍历的顺序存放完全二叉树的结点，下标为 0 处为堆顶，下标为 len - 1 处为堆尾。
2. 结点 i 如果存在左孩子（下标不超过 len - 1 就存在），左孩子的下标为（2 * i ）；如果存在右孩子，右孩子的下标为（2 * i + 1）。结点 i 的父结点下标为 [i  / 2] (下标为 0 的结点除外，它没有父结点)。**最后一个非叶子结点即为堆尾元素的父结点，下标为 (len - 1 - 1) / 2 = (len - 2) / 2。**

## 3. 算法描述(最大堆)

1. 将初始待排序关键字序列(R1,R2….Rn)构建成大根堆，此堆为初始的无序区；
2. 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
3. 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为（n-1），则整个排序过程完成。

#### 动态演示

![堆排序](.\图片\堆排序.gif)

## 4. 算法实现

```java
// 声明全局变量，用于记录数组array的长度；
static int len;

// 堆排序算法
public static int[] heapSort(int[] array) {
    len = array.length;
    if (len == 0)
        return array;
    
    // 1.构建一个大根堆
    buildMaxHeap(array);
    
    // 2.循环将堆顶（最大值）与堆尾交换，删除堆尾元素，然后重新调整大根堆
    while (len > 0) {
        swap(array, 0, len - 1);
        len--; // 原先的堆尾进入有序区，删除堆尾元素
        adjustHeap(array, 0); // 重新调整大根堆, 这里是根节点,为0
    }
    return array;
}

// 自顶向下调整以 i为根的堆为大根堆
public static void adjustHeap(int[] array, int i) {
    // ! 这里错写成 maxIndex = array[i];
    int maxIndex = i;
    
    // ！这里两次比较值的大小都是与 arr[maxIndex] 相比较, 要找出三个值中的最大值
    // 如果有左子树，且左子树大于父节点，则将最大指针指向左子树
    if (2 * i < len && array[2 * i] > array[maxIndex])
        maxIndex = 2 * i;
    // 如果有右子树，且右子树大于父节点，则将最大指针指向右子树
    if (2 * i + 1 < len && array[2 * i + 1] > array[maxIndex])
        maxIndex = 2 * i + 1;
    //！ 如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。
    if (maxIndex != i) {
        swap(array, maxIndex, i);
        adjustHeap(array, maxIndex);
    }
}

// 自底向上构建初始大根堆
public static void buildMaxHeap(int[] array) {
    // 从最后一个非叶子节点开始自底向上构造大根堆
    for (int i = (len - 2) / 2; i >= 0; i--) {
        adjustHeap(array, i);
    }
}

public static void swap(int[] array, int i, int j) {
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
}
```

> 很容易把maxIndex = i 写成 maxIndex = array[i] 之类的错误

#### 拓展

 **1）插入元素：**只需要把待插入的元素放置在堆尾，然后 len++ 把其纳入堆，然后调用 adjustHeap 函数重新调整堆即可。

 **2）删除堆顶元素：**只需要把堆顶元素交换到堆尾，然后 len-- 把其移出堆，然后调用 adjustHeap 函数重新调整堆即可

## 5. 算法分析

| 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 排序方式 | 稳定性 |
| :------------: | :------: | :------: | :--------: | :------: | :----: |
|    O(nlogn)    | O(nlogn) | O(nlogn) |    O(1)    | 外部排序 | 不稳定 |

### 解析 

- **时间复杂度:** 堆排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)