# 冒泡排序（Bubble Sort）

## 1. 算法思想

将待排序的记录排成**一个垂直的序列**，而不是一个水平的序列，把记录想象成水箱里的气泡，其关键字相当于气泡的重量，对所有待排序的记录扫描一趟后，通过两个相邻记录之间的比较和交换使得气泡下沉或上升到其重量应该到的最终位置上

## 2. 算法描述

1. 比较相邻的元素。如果前一个比后一个大，就交换它们两个；
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3. 针对所有的元素重复以上的步骤，除了最后一个；
4. 重复步骤1~3，直到排序完成。

> 为了优化算法，可以设立一个布尔标识，每趟排序开始前设为false，如果该趟排序发生了交换就置为true，如果一趟排序结束标识仍为false表示该趟排序没有发生交换，即数组已经有序，可以提前结束排序。

#### 动态演示

![冒泡排序](.\图片\冒泡排序.gif)

## 3. 算法实现

**实现难点:** 

1. `i, j` 的下标要把握好
2. 不要忘记可以优化, 提前结束

```java
public static void bubbleSort(int[] array) {

    // 外层循环一次为一趟排序, i代表待排序元素的下标
    for (int i = array.length - 1; i > 0; i--) {
        // 在循环内设置标识，判断这趟排序是否发生了交换
        boolean isSwap = false;
        for (int j = 0; j < i; j++)
            // 如果后面的比前面的小则进行交换
            if (array[j + 1] < array[j]) {
                int temp = array[j + 1];
                array[j + 1] = array[j];
                array[j] = temp;
                isSwap = true;	// 本次进行了交换
            }
        // 如果本次冒泡中都没有交换元素
        if (!isSwap)
            break;
    }
}
```



## 4. 算法分析

| 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 排序方式 | 稳定性 |
| :------------: | :------: | :------: | :--------: | :------: | :----: |
|    O(n^2^)     |   O(n)   | O(n^2^)  |    O(1)    | 内部排序 |  稳定  |

### 解析(未看懂最坏情况)

* **最好情况：**如果待排序元素本来是正序的，那么一趟冒泡排序就可以完成排序工作，比较和移动元素的次数分别是 (n - 1) 和 0，因此最好情况的时间复杂度为O(n)。

* **最坏情况：**如果待排序元素本来是逆序的，需要进行 (n - 1) 趟排序，所需比较和移动次数分别为 `nx(n-1)/2 和 3xnx(n-1)/2`。因此最坏情况下的时间复杂度为O(n^2^)

* **稳定性:** 当 array[j] == array[j+1] 的时候，我们不交换 array[i] 和 array[j]，所以**冒泡排序是稳定的** ,两两比较, 不是跳着比较, 所以是稳定的