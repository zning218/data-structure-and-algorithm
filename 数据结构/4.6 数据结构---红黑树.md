## 红黑树

#### 概念

红黑树依然是一棵二分搜索树, 红黑树在二分搜索树的基础上和 AVL树一样, 添加了一些其他的性质, 来保证他不会退化成为链表, 保证自己在某种程度上是一棵平衡的二叉树

#### 性质

1. 每个节点或者是红色的，或者是黑色的
2. 根节点是黑色的
3. 每一个叶子节点(最后的空节点)是黑色的
4. 如果一个节点是红色的，那么他的孩子节点都是黑色的
5. 从任意一个节点到叶子节点，经过的黑色节点是一样的



## 红黑树与 2-3树的等价性

红黑树与 2-3树是等价的

###### 两者比较

![红黑树与2-3树](C:\Users\zn\Desktop\ALL\秋招\总复习\数据结构与算法\数据结构\图片\树\红黑树\红黑树与2-3树.png)

为了区分 b节点和 c的区别, 由于每个节点都是只有一个父亲, 将b节点做一个特殊的标识, 标记为红色, 以标识 b节点和 c节点的不同连接处为红色, 即为 2-3数中的3-节点

###### 两者转换

![红黑树与2-3树的对应](C:\Users\zn\Desktop\ALL\秋招\总复习\数据结构与算法\数据结构\图片\树\红黑树\红黑树与2-3树的对应.png)

黑节点为普通节点, 红节点都是向左倾斜的节点.  

与 2-3树的对应

```
黑结点 —> 2- 结点或者 3-结点的右结点, 根据左结点的颜色判断到底是什么结点
红结点 —> 3- 结点的左结点
```



#### 解读性质

将红黑树对应到 2-3树进行理解

1. 每个节点或者是红色的，或者是黑色的

   > 没什么好说的

2. 根节点是黑色的

   > 对应 2-3树中根节点为 2-节点, 3-节点的情况, 无论是哪一种, 对应到红黑树, 根节点都为黑色

3. 每一个叶子节点(最后的空节点)是黑色的

   > 是一条定义, 空节点这样的节点是黑色的, 图中没有画出空结点
   >

4. 如果一个节点是红色的，那么他的孩子节点都是黑色的

   > 只有表示 2-3节点中的左节点, 才是红色的, 红色节点的孩子同样是 2-节点, 或者 3-节点, 对应的颜色同样都为黑色, 对黑色节点不成立

5. 从任意一个节点到叶子节点，经过的黑色节点是一样的

   > 核心性质, 2-3树是绝对平衡的, 即到达每个叶子结点的路径长度是相同的, 深度一致. 对应到红黑树, 无论是 2-节点, 还是 3-节点, 其中一定有一个黑节点. 对应本条性质

红黑树是保持"黑平衡"的二叉树, 严格意义上, 不是平衡二叉树. 最大高度为 2logn

红黑树从跟到叶子的最长路径不会超过最短路径的 2倍

#### 比较

* 添加和删除操作, 红黑树比 AVL树要快一些, 因此, 如果经常添加和删除元素, 可以使用红黑树

* 如果存储的数据结构只在于查询, AVL树会更加快一点



## 红黑树添加新元素

2-3树中添加一个新元素

或者添加进 2-节点, 形成一个3-节点

或者添加进 3-节点, 暂时形成一个 4-节点

**添加的结点为红色**

### 1.向红黑树中添加根节点

![添加根结点](C:\Users\zn\Desktop\ALL\秋招\总复习\数据结构与算法\数据结构\图片\树\红黑树\添加根结点.png)

添加根节点, 保证根节点为黑色

### 2. 向红黑树中的 2-节点添加元素

根据添加的位置一共是两种情况

#### 情况一

根节点为42, 添加节点 37, 不需要进行旋转

![添加1](C:\Users\zn\Desktop\ALL\秋招\总复习\数据结构与算法\数据结构\图片\树\红黑树\添加1.png)

#### 情况二: 左旋转

根节点为37, 添加节点 42, 需要进行旋转需要进行**左旋转**

###### 进行旋转

![左旋转2](C:\Users\zn\Desktop\ALL\秋招\总复习\数据结构与算法\数据结构\图片\树\红黑树\左旋转2.png)

先进行旋转, 两个结点相当于进行了位置的变化, 需要改变颜色



### 3. 向红黑树中的 3-节点添加元素

根据添加的位置一共是三种情况

#### 情况一: 颜色反转

向节点为 42, 37的树中添加节点 66

![颜色反转](C:\Users\zn\Desktop\ALL\秋招\总复习\数据结构与算法\数据结构\图片\树\红黑树\颜色反转.png)

2-3树中三个节点都为 2-节点, 所以变为黑色, 如图三

节点 42要进行和父节点融合, 所以调整为红色.如图四.

由图二转为图四, 称为**颜色反转**

#### 情况二: 右旋转 + 颜色反转

 向节点为42, 37的树中添加节点12

![右旋转](C:\Users\zn\Desktop\ALL\秋招\总复习\数据结构与算法\数据结构\图片\树\红黑树\右旋转.png)

添加完后进行右旋转, 如图三

因为是旋转, 所以进行颜色变化, 如图四

节点37要和父节点融合, 所以变为红色.

#### 情况三: 左旋转

向节点42, 37的树中添加节点 40

![左旋转情况3](C:\Users\zn\Desktop\ALL\秋招\总复习\数据结构与算法\数据结构\图片\树\红黑树\左旋转情况3.png)

对节点37, 40 进行左旋转. 如图三, 之后和之前情况二一样

#### 3-节点添加总结

![添加元素总结图](C:\Users\zn\Desktop\ALL\秋招\总复习\数据结构与算法\数据结构\图片\树\红黑树\添加元素总结图.png)



### 红黑树与 AVL树比较

1. 如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。

2. 其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。

3. 总体来说，RB-tree的统计性能是高于AVL的。

所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。

### 性能总结

* 对于完全随机的数据，普通的二分搜索树很好用!

  > **缺点:** 极端情况退化成链表(或者高度不平衡)

* 对于查询较多的使用情况，AVL树很好用!

  > 红黑树牺牲了平衡性(2logn的高度)

* 红黑树, 统计性能更优(综合增删改查所有的操作)



------

##### 参考文章

​	[红黑树真的没你想的那么难](https://mp.weixin.qq.com/s/gaOGm48mnONtV4wEE4uVCA)

​	[漫画：什么是红黑树?](https://mp.weixin.qq.com/s/BE_UdHdwTna9dq-qeTPAAQ)